# 2.変数と式
## 2.1_型と変数
型と変数の領域の大きさを表示する
### ポイント
- sizeof演算子は型名にも変数にも適用できる
- char型の大きさは1バイトで、他の型の大きさは処理系によって異なる。long型は本だと8バイトになっているが、自分の環境は4バイト  
  
### 解　説
### sizeof演算子
- 型のメモリ領域の大きさ、変数のメモリ領域の大きさを得ることができる演算子
- 使い方は`sizeof<型名>`、あるいは`sizeof<変数名>`とする
- printfなどの出力系関数で表示する際の、`%zu`というフォーマット指定子を使う。ただ、整数値を扱うので`%d`でも出力できる。  
  
## 2.2_算術演算時の型変換
### ポイント
- 算術演算でオペランドの型が違うと、型変換のルールに従って型が揃えられる
- 浮動小数点を整数に変換すると、小数点以下は無視される
```c
int x = 10;
int y;
y = x * 0.08; 
//int型の変数xは浮動小数点である0.08を積算する際、型を揃えるため型変換が行われてから計算される。およそ表現できる範囲が広いほうの型に揃えられる。
//ここでは、共通の型は浮動小数である0.08のdoule型に揃えられ、変数xはdoule型に型変換されてから乗算が行わる。また結果もdoule型となる
//代入については代入先の値に自動的に変換される。ここではduole型で計算された値がint型変数のyに代入され、小数点以下は切り捨てられる
```
  
## 2.3_式の評価
### ポイント
- 部分式が演算子ごとに評価され、全体の式の値が求まる
- 部分式の計算結果や型がどうなるかを意識して式を書くこと
```c
#include<stdio.h>
#define PAI 3.14

void main() {
	double r;
	double r3;
	double v;
	int i;
	
	printf("球の半径[cm]？");
	scanf("%lf", &r);
	r3 = r;
	for (i = 0; i < 2; i++) {
		r3 *= r;
	}
	v = (4 * PAI * r3) / 3;
	printf("半径%.1fの球の体積は約%.2fccです\n", r, v);

	return 0;

}
```
設問で、体積を求める式が`V = (4/3) πr³`とあるが、額面通り`(4/3) * π * r³`と計算を行ってしまうと、int型の`4/3`の除算式の値は1.333...の小数点切り捨てられた値`1`となってしまい、結果的に求まるVの値はただの`πr³`になってしまう。  
そのため、式を正しく評価するため分子の計算を先に行い、その結果を3で除算するということで正しく式が評価される。  
  
  
  
## 2.4_演算子の優先順位
### ポイント
- 演算の加減乗除は数学と同じ優先順位で計算される
- それ以外は独自決められているので要確認
- 剰余演算（%）は加減演算（+-）より優先される
- 必要な場合は（）でくくる
  
  

## 2.5_演算子の結合性
### ポイント
- 優先順位が同じ演算子が隣り合う場合、どちらに結合するかは結合性によって決まる

### 考え方
`d = n / x²`という式を作るとき、`d = n / x * x`としてしまうと`演算子/`と`演算子*`の優先順位が同じで、結合性が左結合（（n / x) * x)）となってしまうため、`d = n / (x * x)`と式を変換する必要がある。  
また、代入（＝）は右結合のため、たとえば`x = y = z`とという式は`x = (y = z)`とみなされる。逆にC言語では`(x = y) = z`と書くとエラーになる
  
## 2.6_真偽値
### ポイント
- 比較や論理演算など、条件の成立不成立を調べる演算子の結果は`真なら1`、`偽なら2`となる
  
### 考え方
例えば、`0 < 3 < 3`という式は、数学だと`0 < 3 かつ 3 < 3`と解釈されるため答えは偽となるが、C言語では`(0 < 3) < 3`と解釈され、部分式`(0 < 3)`が真となり式全体では`1 < 3`と解釈されるため、答えは真となる。  
数学の`0 < 3 < 3`をC言語で記述するためには`0 < 3 && 3 < 3`としなければならない。  
  
## 2.7_キャスト
`([型])[式]`でキャスト（型変換）ができる  
```c
#include<stdio.h>

void main() {
	double i, e;

	printf("値？");
	scanf("%lf", &i);
	e = (int)(i * 100); 
	printf("%f", e);
	return 0;
}
```
  

## 2.8_副作用のある演算子
### ポイント
- 式の評価において、式の値を得る以外に何か状態変化を起こすこと（変数の値を変えるとか、ファイルに書き込むとか）を副作用という。
### 考え方
インクリメントする`x++`という書き方は、以下の構文だと1増やす前の値をyに掛けてから1増やすという処理になるが、  
```c
y *= x++;
```
もし、式が`++x`と書いたなら、xを1増やした後の値をyに掛けるという処理になる。
```c
y *= --x;
```
このように演算子の前置、後置で得られる式の処理が変わってくる。  
  
  
### 2.9_代入式の値
### ポイント
- 代入式は値を持ち、その値は代入後の左辺の値となる。  
### 考え方
代入式とは、`x = rand() % 10 + 1`など、=演算子を挟んで右辺の計算結果の値を左辺に代入するという式のこと。  
この代入式は例えば`while文`などの条件式に用いられるとき、`代入された値`が条件式での要素となる。  
つまりどういうことかというと、`while((x = rand() % 10 + 1) != 1)`というwhileの条件式があったとき、`rand() % 10 + 1`で得られた乱数が`xに代入`され、その代入された値が`1でない`なら真となるということである。  
  
### 乱数の生成（おさらい）
- `rand関数`は疑似乱数を生成することができる関数
- `rand関数`のライブラリは`stdlib.h`なのでこれをincludeする必要がある
- `rand関数`は疑似乱数を生成するが、生成する計算の過程でどうしても一定の規則性が出てしまう。
- `rand関数`の規則性を補うため`srand関数`という関数で`rand関数`を初期化する必要がある。
- `srand関数`は、`rand関数`が疑似乱数を生成するための乱数種を設定することができる関数で、`rand関数`の乱数生成に影響を与える処理を行う。
- 因みに`srand関数`で乱数種の初期化を行わずに`rand関数`を使用する場合、乱数種は常に`1`となり、これにより乱数生成に規則性が生まれてしまう。
  
### サンプルプログラム
```c
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

void main() {
	int i, num;
    
    printf("種？");
	scanf("%u", &seed);  //乱数種の要素とする
	srand((unsigned)time(NULL) * seed); //rand関数の初期化

	while ((i = rand() % 10 + 1) != 1) {  //乱数の生成
		printf("%d等です\n", i);
	}
	printf("%d等大当たり！\n", i);
	return 0;
}
```
`srand関数`に乱数種となる値をいれ、`rand関数`を初期化する。乱数種はプログラム実行毎に変更されるよう`time関数`（PC時間を取得できる関数）などで取得し、それに任意の値を掛け合わせたりするとランダム性が向上する。  
`unsigned`としている理由は、符号なし、つまり負の値は取らないようにしているためである。  
乱数を任意の値の範囲を取得したい場合は、生成した乱数から取得したい値の幅で割り、その余りに1を足すとその任意の範囲で乱数が取得できる。  
具体的には、1～10の乱数を取得したいときは、`rand() % 10`でrand関数で生成した乱数を10で割った余りは0~9までの乱数になるので、それに1を足すことで、1~10までの乱数が取得できる。  
1~1000までの乱数を取得したい場合も、同様の考え方で`rand() % 1000 + 1`にすると、rand関数で生成された乱数を1000で割った余りは0~999までの乱数となるので、それに1加えると0～1000までの乱数が取得できる
  

## 2.10_オペランドの評価順序
### ポイント
- AND演算子`&&`、OR演算子`||`、条件演算子`?:`では、オペランドの評価順序が決まっており、通常左のオペランドから評価される
### 解　説
```c
if(4 == 0 && 4 < 5){
}
```
上記のような条件式があった際、AND演算子&&を挟んで左辺4 == 0が偽である時点で条件式が偽になるので、右辺は計算されない。  
つまり左辺から先に評価され、そこで結果が出ない場合に右辺を評価するというのかオペランドの評価順序ということである。  
