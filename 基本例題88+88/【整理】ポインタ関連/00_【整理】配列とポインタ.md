# 配列のポインタの整理
下記のような、`int型配列array`を初期化し、そのアドレスを代入した`配列ポインタp`を宣言したとき
```c
	int array[9] = { 10,20,30,40,50,60,70,80,90 };
	int* p;
	p = array;
```
### 値の取り方
- `p[n]`：配列n番目の値が取れる
- `*(p + n)`：配列n番目の値が取れる
- `*p`：常に配列の先頭の値が取れる

### アドレスの取り方
- `p + n`：配列n番目のアドレスが取れる
- `p`：常に配列の先頭アドレスが取れる

### 構文としての誤り
- `*p[n]`
- `*(p[n])`  
考え方としては、`p`はメモリ、`*p`は値が取れるというのが基準なので、配列n番目の値を取りたいときは`*(p + n)`とするのが基本形  
なので、`*P[n]`という構文は存在しない。`p[n]`という構文で配列n番目の値を取れるのは例外

## Sample
```c
#include<stdio.h>

void main() {
	int array[9] = { 10,20,30,40,50,60,70,80,90 };
	int* p;
	p = array;

	printf("【ポインタ変数で値を取る基本形】\n");
	printf("*p = %d\n", *p);						    //常に配列の先頭の値が取れる
	printf("【ポインタ変数でメモリを取る基本形】\n");
	printf("p = %p\n", p);							    //常に配列の先頭メモリが取れる
	printf("\n", p);

	for (int i = 0; i < 9; i++) {
			printf("--- array[%d] = %d の取り方 ---\n", i, array[i]);
		printf("【値を取る】\n");			
		printf("p[%d] = %d\n", i,p[i]);					//配列i番目の値が取れる
		printf("*(p + %d) = %d\n", i, *(p + i));		//配列i番目の値が取れる
		
		printf("\n", p);
	
		printf("【メモリを取る】\n");		
		printf("p + %d = %p\n", i, p + i);				//配列i番目のメモリが取れる
		
		printf("\n", p);

	}
	return 0;
}
```