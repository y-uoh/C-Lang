# 動的メモリ確保
- メモリを動的に確保するには`malloc()`関数を使用する。
- `malloc()`関数はライブラリ関数なので、`stdlib.h`をインクルードする。
- `malloc()`関数は引数に必要なメモリ領域のサイズをバイト単位で指定する。
- `malloc()`関数は戻り値として、割り当てられたメモリ領域の先頭アドレスが返される
- メモリ割り当てに失敗した場合は、`NULL`を返す（エラー処理で使う）
    
例：10個の要素を持つ`int`型配列を割り当てる場合
```c
int *ptr;                           //malloc()関数の戻り値を受け取るポインタ変数を宣言
ptr = malloc(sizeof(int) * 10);     //malloc()関数によりメモリを確保、戻り値は確保したメモリの先頭アドレスなので、戻り値はポインタ変数に代入する
```
この例では、`int`型のサイズを`sizeof`演算子で取得し、その10倍のバイト数を`malloc()`に渡してる。  
これにより、`int`型のサイズ（4バイト）*　10のメモリ領域が割り当てられる。  
また、`malloc()`の戻り値として割り当てられたメモリ領域の先頭アドレスが、ポインタ変数である`ptr`に代入されている。  
  
割り当てられたメモリ領域は、ポインタ変数を介して、通常の配列と同じように操作することが出来る
```c
ptr[0] = 100; //0番目の要素に100を代入
scanf("%d", &ptr[1]); //1番目の要素に入力値を代入
```
  
<br>
  
## 初期化されたメモリの確保
- `calloc()`関数を使用することで、値が0で初期化されたメモリを確保することができる
- `malloc()`関数と引数が異なるが基本的には同じ考え方
- 第一引数に要素の数を指定する
- 第二引数に要素のサイズを指定する
- メモリ割り当てに失敗した場合は、`NULL`を返す（エラー処理で使う）
  
例：10個の要素を持つ`int`型配列を値が0で初期化された状態でメモリを確保する
```c
int *ptr;                           //calloc()関数の戻り値を受け取るポインタ変数を宣言
ptr = calloc(10, sizeof(int));     //calloc()関数によりメモリを確保、戻り値は確保したメモリの先頭アドレスなので、戻り値はポインタ変数に代入する
```
- 第一引数に要素の数として、`10`を指定
- 第二引数に要素のサイズを指定するために、`int`型のサイズを`sizeof`演算子で取得して、int型のサイズ（4バイト）を指定する  
- これにより、`int`型のサイズ（4バイト）*　10のメモリ領域が割り当てられ、全てのメモリの値は`0`で初期化される
- また、`calloc()`の戻り値として割り当てられたメモリ領域の先頭アドレスが、ポインタ変数である`ptr`に代入されている。 


<br>
  
## メモリの再確保
- `realloc()`関数を使用することで、`malloc()`や`calloc()`で確保したメモリのサイズを変更することができる
- 第一引数にメモリサイズを変更したいポインタ変数を指定する
- 第二引数に再確保したいサイズをバイト単位で指定する
- `realloc()`関数は、第一引数に与えられたメモリオブジェクトを解放し、新たなオブジェクトへのポインタを戻り値として返す
- メモリを再確保した際に、元のオブジェクトの値は新たなオブジェクトへとコピーされる
- メモリの再確保に失敗した場合は、`NULL`を返す（エラー処理で使う）
  
例：`malloc()`で確保したメモリの先頭アドレスをを渡し、変更後のサイズとして`int`型サイズ*20に指定している・
```c
int *ptr;                           //malloc()関数の戻り値を受け取るポインタ変数を宣言
ptr = malloc(sizeof(int) * 10);     //malloc()関数によりメモリを確保、戻り値は確保したメモリの先頭アドレスなので、戻り値はポインタ変数に代入する

int *new_ptr;
new_ptr = realloc(ptr, sizeof(int) * 20);
```
- 当初`malloc()`関数で`40`バイト分のメモリを確保
- 次に`ralloc()`関数でメモリを再確保
- `realloc()`関数の第一引数に、サイズを変更したいメモリの先頭アドレスを渡すため、ポインタ変数`ptr`を指定する
- `realloc()`関数の第二引数に再確保したいサイズをバイト単位で指定するために、`int`型のサイズを`sizeof`演算子で取得して、`int型のサイズ（4バイト） * 20バイト`を指定する  
- これにより、`int`型のサイズ（4バイト）*　20のメモリ領域が新たに`new_ptr`に再確保される
  
<br>
  
## メモリ確保の注意
### 1.確保したメモリの解放
- 動的に確保したメモリ領域は、使用後に必ず解放する必要がある。  
- 解放しないことでメモリリークが発生し、システム全体のメモリを使いつくしてしまう可能性がある  
- メモリの確保と解放を関数内で行うプログラムにすることで、確認が容易となり、メモリリークの発生を抑止することができる
  
解放するためには、`free()`関数を使用する
```c
int *ptr;                           //malloc()関数の戻り値を受け取るポインタ変数を宣言
ptr = malloc(sizeof(int) * 10);     //malloc()関数によりメモリを確保、戻り値は確保したメモリの先頭アドレスなので、戻り値はポインタ変数に代入する

free(ptr);                          //free()関数でメモリを開放する。ポインタ変数を引数にすることでメモリは解放される
```
  
### 2.メモリの二重解放をしない
- 動的に確保したメモリを一度解放した後、再度同じ領域を解放すると未定義の動作となる
- 解放されたメモリは、どこかで再利用されている可能性もあるため、二重解放によってプログラム全体が不安定になったりクラッシュする可能性があるため注意が必要
  
`free()`関数は、引数に`NULL`が指定された場合、何の動作も行われない仕様になっているため、メモリ解放した後のポインタ変数には`NULL`を代入することが推奨されている
```c
int *ptr;                           //malloc()関数の戻り値を受け取るポインタ変数を宣言
ptr = malloc(sizeof(int) * 10);     //malloc()関数によりメモリを確保、戻り値は確保したメモリの先頭アドレスなので、戻り値はポインタ変数に代入する

free(ptr);                          //free()関数でメモリを開放する。ポインタ変数を引数にすることでメモリは解放される
ptr = NULL;                         //間違えて二重解放してもfree()関数は引数にNULLがあれば何もしないので安心
```
  
### 3.エラー処理をする
- 動的メモリ確保は失敗する可能性があるため、エラー処理は必ず行う必要がある
- メモリ確保に失敗した場合、`malloc()`関数の戻り値は`NULL`を返すようになっているため、`malloc()`関数の戻り値が`NULL`になっていないかを確認する
  
エラー処理の方法はさまざまある。以下は一例
- `if`文でポインタ変数にNULLが代入されていないを条件式とする
- `perror()`関数は、引数に指定したライブラリ関数が行った直前の処理で起きたエラーについて、簡単なメッセージを返す
  - 例）メモリ不足で領域が確保できなかった時のエラーメッセージ　-> `malloc: Cannot allocate memory`
- exit()関数は、プログラムの実行を終了させるライブラリ関数。引数にマクロ定義された値などをいれると何故終了するかを示せる
  - 例）失敗終了 -> exit(EXIT_FAILURE)
```c
int *ptr;                           //malloc()関数の戻り値を受け取るポインタ変数を宣言
ptr = malloc(sizeof(int) * 10);     //malloc()関数によりメモリを確保、戻り値は確保したメモリの先頭アドレスなので、戻り値はポインタ変数に代入する

if(ptr == NULL){
    perror("malloc");
    exit(EXIT_FAILURE);
}
```
