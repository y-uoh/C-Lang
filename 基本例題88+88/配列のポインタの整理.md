# 配列のポインタの整理
下記のように、int型配列arrayの配列ポインタpを宣言したとき
```c
	int array[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int* p;
	p = array;
```
### 値の取り方
- `p[n]`：配列n番目の値が取れる
- `*p + n`：配列n番目の値が取れる
- `*(p + n)`：配列n番目の値が取れる
- `*p`：常に配列の先頭の値が取れる

### メモリの取り方
- `p + n`：配列n番目のメモリが取れる
- `p`：常に配列の先頭メモリが取れる

### 構文としての誤り
- `*p[n]`
- `*(p[n])`  
考え方としては、`p`はメモリ、`*p`は値が取れるというのが基準なので、配列n番目の値を取りたいときは`*p + n`とするのが基本形  
なので、`*P[n]`という構文は存在しない。`p[n]`という構文で配列n番目の値を取れるのは例外

## Sample
```c
#include<stdio.h>

void main() {
	int array[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int* p;
	p = array;

	printf("【ポインタ変数で値を取る基本形】\n");
	printf("*p = %d\n", *p);						    //常に配列の先頭の値が取れる
	printf("【ポインタ変数でメモリを取る基本形】\n");
	printf("p = %p\n", p);							    //常に配列の先頭メモリが取れる
	printf("\n", p);

	for (int i = 0; i < 10; i++) {
			printf("--- array[%d] = %d の取り方 ---\n", i, array[i]);
		printf("【値を取る】\n");			
		printf("p[%d] = %d\n", i,p[i]);					//配列i番目の値が取れる
		printf("*p + %d = %d\n", i, *p + i);			//配列i番目の値が取れる
		printf("*(p + %d) = %d\n", i, *(p + i));		//配列i番目の値が取れる
		
		printf("\n", p);
	
		printf("【メモリを取る】\n");		
		printf("p + %d = %p\n", i, p + i);				//配列i番目のメモリが取れる
		
		printf("\n", p);

	}
	return 0;
}
```